#!/bin/bash
#$Id: _base_script_block.wrap,v 1.1 2012-05-07 13:47:27 remik Exp $
#
# That script is to be used ONLY on test env
#

# Load usefull functions
if [ ! -f $HOME/scripto/bash/bash_library.sh ]; then
  echo "[error] $HOME/scripto/bash/bash_library.sh not found. Exiting. "
  exit 1
else
  . $HOME/scripto/bash/bash_library.sh
fi

INFO_MODE=DEBUG
#INFO_MODE=INFO

F_TMP=/tmp/restore_scenario.tmp

# Functions
# ---------

# cqlsh sanity check
f_cqlsh_sanity_check()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgd "Picking one docker to execute commands"
  V_DOCKER=`echo $V_DOCKER_LIST | awk -F"," '{print $1}'`

  msgd "check if I can properly login to cqlsh"
  msgd "V_DOCKER: $V_DOCKER"
  msgd "V_CQLSHRC: $V_CQLSHRC"
  msgd "E_CQLSH: $E_CQLSH"

  msgd "Construct docker cqlsh executable command based of whether V_CQLSHRC was set"
  if [ -z $V_CQLSHRC ]; then
    msgd "No V_CQLSHRC set"
    E_CQLSH="docker exec $V_DOCKER cqlsh"
  else
    msgd "V_CQLSHRC set, including that in E_CQLSH"
    E_CQLSH="docker exec $V_DOCKER cqlsh --cqlshrc=$V_CQLSHRC"
  fi
  msgd "E_CQLSH: $E_CQLSH"

  check_parameter $V_DOCKER
  check_parameter $E_CQLSH

  V_TEST_RAW=`$E_CQLSH -e "desc keyspaces;"` 
  msgd "V_TEST_RAW: $V_TEST_RAW"
  V_TEST=`echo $V_TEST_RAW | grep system | wc -l`
  msgd "V_TEST: $V_TEST"
  # when it fails it goes like:
  # Connection error: ('Unable to connect to any servers', {'127.0.0.1': error(111, "Tried connecting to [('127.0.0.1', 9042)]. Last error: Connection refused")})
  # when it works it goes like
  # system_auth    remik1  remik4              system_traces system_schema  system  system_distributed

  if [ "$V_TEST" -gt 0 ]; then
    msgd "Connection works"
  else
    msge "Connection does not work."
    msge "$V_TEST_RAW"
    msge "maybe you need to provide --cqlshrc parameter which point to file in docker with credentials. Exiting."
    exit 1
  fi

  msgd "Construct docker cqlsh executable command based of whether V_CQLSHRC was set"
  if [ -z $V_CQLSHRC ]; then
    msgd "No V_CQLSHRC set"
    E_CQLSH="docker exec $V_DOCKER cqlsh"
  else
    msgd "V_CQLSHRC set, including that in E_CQLSH"
    E_CQLSH="docker exec $V_DOCKER cqlsh --cqlshrc=$V_CQLSHRC"
  fi
  msgd "E_CQLSH: $E_CQLSH"

  msgd "Construct docker sh execution command"
  E_DOCKER="docker exec $V_DOCKER"
  msgd "E_DOCKER: $E_DOCKER"


  msgb "${FUNCNAME[0]} Finished."
} #f_cqlsh_sanity_check


# $1 - keyspace name


f_determine_cassandra_version()
{
  msgb "${FUNCNAME[0]} Beginning."
 
  F_TMP_DV=/tmp/restore.wrap.tmp.dw
  run_command_e "$E_DOCKER nodetool version > $F_TMP_DV 2>&1"
  run_command_d "cat $F_TMP_DV"
  V_CASSANDRA_VERSION=`cat $F_TMP_DV | awk '{print $2}' | awk -F"." '{print $1"."$2}'`
  msgd "V_CASSANDRA_VERSION: $V_CASSANDRA_VERSION"

  case $V_CASSANDRA_VERSION in
  "2.1")
    msgd "Cassandra version $V_CASSANDRA_VERSION"
    Q_KEYSPACE_EXISTS="select keyspace_name from system.schema_keyspaces where keyspace_name" 
    Q_TABLE_EXISTS="select keyspace_name, columnfamily_name from system.schema_columnfamilies where keyspace_name"
    Q_TABLE_EXISTS_AND="and columnfamily_name"
    ;;
  "3.0")
    msgd "Cassandra version $V_CASSANDRA_VERSION"
    Q_KEYSPACE_EXISTS="select keyspace_name from system_schema.keyspaces where keyspace_name" 
    Q_TABLE_EXISTS="select keyspace_name, table_name from system_schema.tables where keyspace_name"
    Q_TABLE_EXISTS_AND="and table_name"
    ;;
  *)
    echo "Unknown cassandra version!!! Exiting."
    exit 1
    ;;
  esac

  msgd "Setting following variables as dependent on cassandra version"
  msgd "Q_KEYSPACE_EXISTS: $Q_KEYSPACE_EXISTS"
  msgd "Q_TABLE_EXISTS: $Q_TABLE_EXISTS"
  msgd "Q_TABLE_EXISTS_AND: $Q_TABLE_EXISTS_AND"

  msgb "${FUNCNAME[0]} Finished."
} #f_determine_cassandra_version

f_create_phase()
{
  msgb "${FUNCNAME[0]} Beginning."
  msgd "Using global variables"
  msgd "V_CREATE_PHASE_FILE: $V_CREATE_PHASE_FILE"
  msgd "V_DOCKER: $V_DOCKER"

  check_parameter $V_CREATE_PHASE_FILE
  check_parameter $V_CREATE_PHASE_FILE

  msgd "Copy file to docker"
  run_command_e "docker cp $V_CREATE_PHASE_FILE $V_DOCKER:/tmp"

  msgd "Executing script"
  run_command_e "$E_CQLSH -f /tmp/$V_CREATE_PHASE_FILE"

  msgb "${FUNCNAME[0]} Finished."
} #f_create_phase


f_check_phase()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #f_check_phase

f_backup_phase()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #f_backup_phase

f_destroy_phase()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #f_destroy_phase

f_restore_phase()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #f_restore_phase

f_compare_checks()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #f_compare_checks


f_template()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #b_template


msgi "Hellow World"

# Validate Input/Environment
# --------------------------
# Great sample getopt implementation by Cosimo Streppone
# https://gist.github.com/cosimo/3760587#file-parse-options-sh
SHORT='hd:r:c:d:'
LONG='help,docker_list:,cqlshrc:,create_phase_file:,destroy_phase_file:'
OPTS=$( getopt -o $SHORT --long $LONG -n "$0" -- "$@" )

if [ $? -gt 0 ]; then
    # Exit early if argument parsing failed
    printf "Error parsing command arguments\n" >&2
    exit 1
fi
eval set -- "$OPTS"
while true; do
    case "$1" in
            -h|--help) usage;;
            -d|--docker_list) V_DOCKER_LIST="$2"; shift 2;;
            -r|--cqlshrc) V_CQLSHRC="$2"; shift 2;;
            -c|--create_phase_file) V_CREATE_PHASE_FILE="$2"; shift 2;;
            -d|--destroy_phase_file) V_DESTROY_PHASE_FILE="$2"; shift 2;;
            --) shift; break;;
            *) printf "Error processing command arguments\n" >&2; exit 1;;
    esac
done

# # # Sanity checks

msgd "Actual execution"

f_cqlsh_sanity_check

f_create_phase
f_check_phase
f_backup_phase
f_destroy_phase
f_restore_phase
f_check_phase
f_compare_checks


msgi "Done."

