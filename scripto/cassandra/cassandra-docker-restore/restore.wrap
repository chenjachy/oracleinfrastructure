#!/bin/bash
#$Id: _base_script_block.wrap,v 1.1 2012-05-07 13:47:27 remik Exp $
#

# Load usefull functions
if [ ! -f $HOME/scripto/bash/bash_library.sh ]; then
  echo "[error] $HOME/scripto/bash/bash_library.sh not found. Exiting. "
  exit 1
else
  . $HOME/scripto/bash/bash_library.sh
fi

INFO_MODE=DEBUG
#INFO_MODE=INFO

# Functions
# ---------

  function usage() {
        printf "Usage: $0 -h\n"
        printf "       $0 -f <snapshot file> [-n <node address>] [-k <new ks name>] [-d <new dc name>] [-r <new rf>] [-y <cassandra.yaml file>]\n"
        printf "    -h,--help                          Print usage and exit\n"
        printf "    -v,--version                       Print version information and exit\n"
        printf "    -f,--file <snapshot file>          REQUIRED: The snapshot file name (created using the\n"
        printf "                                       getSnapshot utility\n"
        printf "    -n,--node <node address>           Destination Cassandra node IP (defaults to the local\n"
        printf "                                       Cassandra IP if run on a Cassandra node, otherwise\n"
        printf "                                       required in order to connect to Cassandra.  Will take\n"
        printf "                                       precedence if provided and run on a Cassandra node\n"
        printf "    -k,--keyspace <new ks name>        Override the destination keyspace name (defaults to\n"
        printf "                                       the source keyspace name)\n"
        printf "    -d,--datacenter <new dc name>      Override the destination datacenter name (defaults\n"
        printf "                                       to the sourcen datacenter name)\n"
        printf "    -r,--replication <new rf>          Override the destination replication factor (defaults\n"
        printf "                                       to source replication factor)\n"
        printf "    -y,--yaml <cassandra.yaml file>    Alternate cassandra.yaml file\n"
        exit 0
  }

# cqlsh sanity check
f_cqlsh_sanity_check()
{
  msgb "${FUNCNAME[0]} Beginning."
  msgd "check if I can properly login to cqlsh"
  msgd "V_DOCKER: $V_DOCKER"
  msgd "V_CQLSHRC: $V_CQLSHRC"
  msgd "E_CQLSH: $E_CQLSH"

  V_TEST_RAW=`$E_CQLSH -e "desc keyspaces;"` 
  msgd "V_TEST_RAW: $V_TEST_RAW"
  V_TEST=`echo $V_TEST_RAW | grep system | wc -l`
  msgd "V_TEST: $V_TEST"
  # when it fails it goes like:
  # Connection error: ('Unable to connect to any servers', {'127.0.0.1': error(111, "Tried connecting to [('127.0.0.1', 9042)]. Last error: Connection refused")})
  # when it works it goes like
  # system_auth    remik1  remik4              system_traces system_schema  system  system_distributed

  if [ "$V_TEST" -gt 0 ]; then
    msgd "Connection works"
  else
    msge "Connection does not work."
    msge "$V_TEST_RAW"
    msge "maybe you need to provide --cqlshrc parameter which point to file in docker with credentials. Exiting."
    exit 1
  fi


#WIP

  msgb "${FUNCNAME[0]} Finished."
} #f_cqlsh_sanity_check


# $1 - keyspace name
f_check_if_keyspace_exists()
{
  msgb "${FUNCNAME[0]} Beginning."
  V_KEYSPACE_CHECK=$1
  msgd "V_KEYSPACE_CHECK: $V_KEYSPACE_CHECK"

 
#WIP
  
  V_CHECK_IF_KEYSPACE_EXISTS=yes
  msgb "${FUNCNAME[0]} Finished."
} #f_check_if_keyspace_exists

f_check_if_table_exists()
{
  msgb "${FUNCNAME[0]} Beginning."

  V_CHECK_IF_TABLE_EXISTS=yes
  msgb "${FUNCNAME[0]} Finished."
} #f_check_if_table_exists

f_load_table()
{
  msgb "${FUNCNAME[0]} Beginning."
  msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"
  msgd "Keyspace exists, table does not. Creating table and loading data"
  msgd "Somehow you need to create table once (using script from first backup file) then load data from all the backup files, if they exist"
  msgd "Or if V_IGNORE_TABLE_EXISTS is yes just load the data from all the backups"
  msgd "Table Restore Done."

  msgb "${FUNCNAME[0]} Finished."
} #f_load_table


f_template()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #b_template



msgi "Hellow World"

# Validate Input/Environment
# --------------------------
    # Great sample getopt implementation by Cosimo Streppone
    # https://gist.github.com/cosimo/3760587#file-parse-options-sh
    SHORT='h:f:d:r:k:t:i:j:'
    LONG='help,backup_file:,docker:,cqlshrc:,keyspace:,table:,ignore_keyspace_exists:,ignore_table_exists:'
    OPTS=$( getopt -o $SHORT --long $LONG -n "$0" -- "$@" )

    if [ $? -gt 0 ]; then
        # Exit early if argument parsing failed
        printf "Error parsing command arguments\n" >&2
        exit 1
    fi
    eval set -- "$OPTS"
    while true; do
        case "$1" in
            -h|--help) usage;;
            -f|--backup_file) V_BACKUP_FILE="$2"; shift 2;;
            -d|--docker) V_DOCKER="$2"; shift 2;;
            -r|--cqlshrc) V_CQLSHRC="$2"; shift 2;;
            -k|--keyspace) V_KEYSPACE="$2"; shift 2;;
            -t|--table) V_TABLE="$2"; shift 2;;
            -i|--ignore_keyspace_exists) V_IGNORE_KEYSPACE_EXISTS="$2"; shift 2;;
            -j|--ignore_table_exists) V_IGNORE_TABLE_EXISTS="$2"; shift 2;;
            --) shift; break;;
            *) printf "Error processing command arguments\n" >&2; exit 1;;
        esac
    done

# # # Sanity checks
msgd "V_DOCKER: $V_DOCKER"
check_parameter $V_DOCKER
msgd "V_CQLSHRC: $V_CQLSHRC"

msgd "V_BACKUP_FILE: $V_BACKUP_FILE"
msgd "V_KEYSPACE: $V_KEYSPACE"
msgd "V_IGNORE_KEYSPACE_EXISTS: $V_IGNORE_KEYSPACE_EXISTS"
msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"

msgd "Construct docker executable command based of whether V_CQLSHRC was set"
if [ -z $V_CQLSHRC ]; then
  msgd "No V_CQLSHRC set"
  E_CQLSH="docker exec $V_DOCKER cqlsh"
else
  msgd "V_CQLSHRC set, including that in E_CQLSH"
  E_CQLSH="docker exec $V_DOCKER cqlsh --cqlshrc=$V_CQLSHRC"
fi
msgd "E_CQLSH: $E_CQLSH"

f_cqlsh_sanity_check
exit 0

# # #
msgd "Set some defaults if they were not set explicitly"
if [ -z "$V_IGNORE_KEYSPACE_EXISTS" ]; then
  msgd "V_IGNORE_KEYSPACE_EXISTS was not set explicitly, setting to no"
  V_IGNORE_KEYSPACE_EXISTS=no
fi
if [ -z "$V_IGNORE_TABLE_EXISTS" ]; then
  msgd "V_IGNORE_TABLE_EXISTS was not set explicitly, setting to no"
  V_IGNORE_TABLE_EXISTS=no
fi

msgd "V_IGNORE_KEYSPACE_EXISTS: $V_IGNORE_KEYSPACE_EXISTS"
msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"

# # # Actual execution
# # # restore a table
msgd "Check what should I do"
if [ "$V_KEYSPACE" ] && [ "$V_TABLE" ]; then
  msgd "Both keyspace and table is provided, so I am about to restore a table"
  f_check_if_keyspace_exists $V_KEYSPACE

#WIP
exit 0
  msgd "V_CHECK_IF_KEYSPACE_EXISTS: $V_CHECK_IF_KEYSPACE_EXISTS"
  if [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "no" ]; then
    msge "You want to restore a table in a keyspace but the keyspace does not exists. Exiting."
  elif [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "yes" ]; then
    msgd "Keyspace exists. Continuing."
    msgd "Checking if table already exists"
    f_check_if_table_exists $V_KEYSPACE $V_TABLE
    msgd "V_CHECK_IF_TABLE_EXISTS: $V_CHECK_IF_TABLE_EXISTS"
    if [ "$V_CHECK_IF_TABLE_EXISTS" = "no" ]; then
      msgd "Keyspace exists, table does not. Creating table and loading data"
      f_load_table $V_KEYSPACE $V_TABLE
    elif [ "$V_CHECK_IF_TABLE_EXISTS" = "yes" ]; then
      msgd "Keyspace exists, table exists. Deciding what to do based on V_IGNORE_TABLE_EXISTS value"
      if [ "$V_IGNORE_TABLE_EXISTS" = "no" ]; then
        msge "Table $V_TABLE already exists in the keyspace $V_KEYSPACE."
        msge "There was no parameter set to ignore it (use '--ignore_table_exists yes' to force loading data anyway) "
        msge "Exiting."
        exit 1
      elif [ "$V_IGNORE_TABLE_EXISTS" = "yes" ]; then
        msgd "Table $V_TABLE already exists in the keyspace $V_KEYSPACE."
        msgd "There WAS parameter set to ignore it, loading data anyway) "
        f_load_table $V_KEYSPACE $V_TABLE
      else
        msge "Unknown value of V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS. Exiting"
        exit 1 
      fi
    else
      msge "Unknown value of V_CHECK_IF_TABLE_EXISTS: $V_CHECK_IF_TABLE_EXISTS. Exiting"
      exit 1
    fi
  else
    msge "Unknown value of V_CHECK_IF_KEYSPACE_EXISTS: $V_CHECK_IF_KEYSPACE_EXISTS. Exiting"
  fi #  if [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "no" ]; then

elif [ "$V_KEYSPACE" ] && [ -z "$V_TABLE" ]; then
  msgd "Only keyspace provided, so I am about to restore keyspace" 
else
  msge "Provide keyspace"
fi



msgd "Check if sstableloader exists in docker"




