#!/bin/bash
#$Id: _base_script_block.wrap,v 1.1 2012-05-07 13:47:27 remik Exp $
#

# Load usefull functions
if [ ! -f $HOME/scripto/bash/bash_library.sh ]; then
  echo "[error] $HOME/scripto/bash/bash_library.sh not found. Exiting. "
  exit 1
else
  . $HOME/scripto/bash/bash_library.sh
fi

INFO_MODE=DEBUG
#INFO_MODE=INFO

# Functions
# ---------

  function usage() {
        printf "Usage: $0 -h\n"
        printf "       $0 -f <snapshot file> [-n <node address>] [-k <new ks name>] [-d <new dc name>] [-r <new rf>] [-y <cassandra.yaml file>]\n"
        printf "    -h,--help                          Print usage and exit\n"
        printf "    -v,--version                       Print version information and exit\n"
        printf "    -f,--file <snapshot file>          REQUIRED: The snapshot file name (created using the\n"
        printf "                                       getSnapshot utility\n"
        printf "    -n,--node <node address>           Destination Cassandra node IP (defaults to the local\n"
        printf "                                       Cassandra IP if run on a Cassandra node, otherwise\n"
        printf "                                       required in order to connect to Cassandra.  Will take\n"
        printf "                                       precedence if provided and run on a Cassandra node\n"
        printf "    -k,--keyspace <new ks name>        Override the destination keyspace name (defaults to\n"
        printf "                                       the source keyspace name)\n"
        printf "    -d,--datacenter <new dc name>      Override the destination datacenter name (defaults\n"
        printf "                                       to the sourcen datacenter name)\n"
        printf "    -r,--replication <new rf>          Override the destination replication factor (defaults\n"
        printf "                                       to source replication factor)\n"
        printf "    -y,--yaml <cassandra.yaml file>    Alternate cassandra.yaml file\n"
        exit 0
  }

# cqlsh sanity check
f_cqlsh_sanity_check()
{
  msgb "${FUNCNAME[0]} Beginning."
  msgd "check if I can properly login to cqlsh"
  msgd "V_DOCKER: $V_DOCKER"
  msgd "V_CQLSHRC: $V_CQLSHRC"
  msgd "E_CQLSH: $E_CQLSH"

  V_TEST_RAW=`$E_CQLSH -e "desc keyspaces;"` 
  msgd "V_TEST_RAW: $V_TEST_RAW"
  V_TEST=`echo $V_TEST_RAW | grep system | wc -l`
  msgd "V_TEST: $V_TEST"
  # when it fails it goes like:
  # Connection error: ('Unable to connect to any servers', {'127.0.0.1': error(111, "Tried connecting to [('127.0.0.1', 9042)]. Last error: Connection refused")})
  # when it works it goes like
  # system_auth    remik1  remik4              system_traces system_schema  system  system_distributed

  if [ "$V_TEST" -gt 0 ]; then
    msgd "Connection works"
  else
    msge "Connection does not work."
    msge "$V_TEST_RAW"
    msge "maybe you need to provide --cqlshrc parameter which point to file in docker with credentials. Exiting."
    exit 1
  fi

  msgb "${FUNCNAME[0]} Finished."
} #f_cqlsh_sanity_check


# $1 - keyspace name
f_check_if_keyspace_exists()
{
  msgb "${FUNCNAME[0]} Beginning."
  V_KEYSPACE_CHECK=$1
  msgd "V_KEYSPACE_CHECK: $V_KEYSPACE_CHECK"


  V_TEST_QUERY="select keyspace_name from system_schema.keyspaces where keyspace_name = '$V_KEYSPACE_CHECK' ;" 
  msgd "V_TEST_QUERY: $V_TEST_QUERY"
  V_TEST_RAW=`$E_CQLSH -e "$V_TEST_QUERY"` 
  msgd "V_TEST_RAW: $V_TEST_RAW"
  V_TEST=`echo $V_TEST_RAW | grep $V_KEYSPACE_CHECK | wc -l`
  msgd "V_TEST: $V_TEST"

  if [ "$V_TEST" -gt 0 ]; then
    msgd "Keyspace $V_KEYSPACE_CHECK exists."
    V_CHECK_IF_KEYSPACE_EXISTS=yes
  else
    msgd "Keyspace $V_KEYSPACE_CHECK does NOT exists."
    V_CHECK_IF_KEYSPACE_EXISTS=no
  fi
  msgd "V_CHECK_IF_KEYSPACE_EXISTS: $V_CHECK_IF_KEYSPACE_EXISTS"
  
  msgb "${FUNCNAME[0]} Finished."
} #f_check_if_keyspace_exists

f_check_if_table_exists()
{
  msgb "${FUNCNAME[0]} Beginning."
  V_KEYSPACE_CHECK=$1
  msgd "V_KEYSPACE_CHECK: $V_KEYSPACE_CHECK"
  check_parameter $V_KEYSPACE_CHECK
  V_TABLE_CHECK=$2
  msgd "V_TABLE_CHECK: $V_TABLE_CHECK"
  check_parameter $V_TABLE_CHECK

  V_TEST_QUERY="select keyspace_name, table_name from system_schema.tables where keyspace_name='$V_KEYSPACE_CHECK' and table_name='$V_TABLE_CHECK';"

  msgd "V_TEST_QUERY: $V_TEST_QUERY"
  V_TEST_RAW=`$E_CQLSH -e "$V_TEST_QUERY"` 
  msgd "V_TEST_RAW: $V_TEST_RAW"
  V_TEST=`echo $V_TEST_RAW | grep $V_KEYSPACE_CHECK | grep $V_TABLE_CHECK | wc -l`
  msgd "V_TEST: $V_TEST"

  if [ "$V_TEST" -gt 0 ]; then
    msgd "Table ${V_KEYSPACE_CHECK}.${V_TABLE_CHECK} exists."
    V_CHECK_IF_TABLE_EXISTS=yes
  else
    msgd "Table ${V_KEYSPACE_CHECK}.${V_TABLE_CHECK} does NOT exists."
    V_CHECK_IF_TABLE_EXISTS=no
  fi
  msgd "V_CHECK_IF_TABLE_EXISTS: $V_CHECK_IF_TABLE_EXISTS"

  msgb "${FUNCNAME[0]} Finished."
} #f_check_if_table_exists

f_load_table()
{
  msgb "${FUNCNAME[0]} Beginning."

  # using following variables passed as parameters
  V_KEYSPACE_CHECK=$1
  msgd "V_KEYSPACE_CHECK: $V_KEYSPACE_CHECK"
  check_parameter $V_KEYSPACE_CHECK
  V_TABLE_CHECK=$2
  msgd "V_TABLE_CHECK: $V_TABLE_CHECK"
  check_parameter $V_TABLE_CHECK
 
  # using folowing global variables
  msgd "V_BACKUP_FILES: $V_BACKUP_FILES" 
  check_parameter $V_BACKUP_FILES
  msgd "V_RESTORE_TEMP_DIR: $V_RESTORE_TEMP_DIR"
  check_parameter $V_RESTORE_TEMP_DIR

  f_extract_backup_files
#WIP
exit 0


  msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"
  msgd "Keyspace exists, table does not. Creating table and loading data"
  msgd "Somehow you need to create table once (using script from first backup file) then load data from all the backup files, if they exist"
  msgd "Or if V_IGNORE_TABLE_EXISTS is yes just load the data from all the backups"
  msgd "Table Restore Done."
# structure created with f_create_table_structure

  msgb "${FUNCNAME[0]} Finished."
} #f_load_table

f_extract_backup_files()
{
  msgb "${FUNCNAME[0]} Beginning."
  # using folowing global variables
  msgd "V_BACKUP_FILES: $V_BACKUP_FILES" 
  check_parameter $V_BACKUP_FILES
  msgd "V_RESTORE_TEMP_DIR: $V_RESTORE_TEMP_DIR"
  check_parameter $V_RESTORE_TEMP_DIR

  msgd "Extract backup tag"
  V_BACKUP_TAG=`echo $V_BACKUP_FILES | awk -F"," '{print $1}' | awk -F"/" '{print $NF}' | awk -F"." '{print $1}'`
  msgd "V_BACKUP_TAG: $V_BACKUP_TAG"

  msgd "Check if backups are already extracted on temp dir "
  V_TEMP=`$E_DOCKER ls -d $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG 2>&1`
  msgd "V_TEMP: $V_TEMP"
  V_TEMP_C=`echo $V_TEMP | grep "No such file or directory" | wc -l`
  msgd "V_TEMP_C: $V_TEMP_C"
  if [ "$V_TEMP_C" -gt 0 ]; then
    msgd "No extraction was taking place. Will do that now"
    
    msgd "Check if temp dir is writable"
    V_TEMP=`$E_DOCKER mkdir $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG 2>&1`
    msgd "V_TEMP: $V_TEMP"
    V_TEMP_C=`echo $V_TEMP | grep -v '^ *$' | wc -l`
    msgd "V_TEMP_C: $V_TEMP_C"
    if [ "$V_TEMP_C" -gt 0 ]; then
      msge "Unable to create $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG dir, exiting."
      exit 1
    fi #Check if temp dir is writable

    msgd "Created new empty directory, now extracting backup files each in ints own dir"
    msgd "Looping through the backup files"
    CURRENT=1
    for i in `echo $V_BACKUP_FILES | sed 's/,/\n/g'`
    do
      msgd "Extracting: $i"
      run_command_e "$E_DOCKER mkdir $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG/$CURRENT"
      run_command_e "$E_DOCKER tar xzf $i -C $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG/$CURRENT"
      CURRENT=`expr ${CURRENT} + 1`
    done
   
  else
    msgd "Extract dir $V_RESTORE_TEMP_DIR/$V_BACKUP_TAG is already there, doing nothing."
    
  fi #Check if backups are already extracted on temp dir
    
  msgb "${FUNCNAME[0]} Finished."
} #f_extract_backup_files

# This assumes that I have already backup extracted and now just need to create table structure
f_create_table_structure()
{
  msgb "${FUNCNAME[0]} Beginning."

#WIP

  msgb "${FUNCNAME[0]} Finished."
} #f_create_table_structure



f_template()
{
  msgb "${FUNCNAME[0]} Beginning."

  msgb "${FUNCNAME[0]} Finished."
} #b_template



msgi "Hellow World"

# Validate Input/Environment
# --------------------------
# Great sample getopt implementation by Cosimo Streppone
# https://gist.github.com/cosimo/3760587#file-parse-options-sh
SHORT='h:f:s:d:r:k:t:i:j:'
LONG='help,backup_files:,restore_temp_dir:,docker:,cqlshrc:,keyspace:,table:,ignore_keyspace_exists:,ignore_table_exists:'
OPTS=$( getopt -o $SHORT --long $LONG -n "$0" -- "$@" )

if [ $? -gt 0 ]; then
    # Exit early if argument parsing failed
    printf "Error parsing command arguments\n" >&2
    exit 1
fi
eval set -- "$OPTS"
while true; do
    case "$1" in
            -h|--help) usage;;
            -f|--backup_files) V_BACKUP_FILES="$2"; shift 2;;
            -s|--restore_temp_dir) V_RESTORE_TEMP_DIR="$2"; shift 2;;
            -d|--docker) V_DOCKER="$2"; shift 2;;
            -r|--cqlshrc) V_CQLSHRC="$2"; shift 2;;
            -k|--keyspace) V_KEYSPACE="$2"; shift 2;;
            -t|--table) V_TABLE="$2"; shift 2;;
            -i|--ignore_keyspace_exists) V_IGNORE_KEYSPACE_EXISTS="$2"; shift 2;;
            -j|--ignore_table_exists) V_IGNORE_TABLE_EXISTS="$2"; shift 2;;
            --) shift; break;;
            *) printf "Error processing command arguments\n" >&2; exit 1;;
    esac
done

# # # Sanity checks
msgd "V_DOCKER: $V_DOCKER"
check_parameter $V_DOCKER
msgd "V_CQLSHRC: $V_CQLSHRC"

msgd "V_BACKUP_FILES: $V_BACKUP_FILES"
msgd "V_KEYSPACE: $V_KEYSPACE"
msgd "V_IGNORE_KEYSPACE_EXISTS: $V_IGNORE_KEYSPACE_EXISTS"
msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"

msgd "Construct docker cqlsh executable command based of whether V_CQLSHRC was set"
if [ -z $V_CQLSHRC ]; then
  msgd "No V_CQLSHRC set"
  E_CQLSH="docker exec $V_DOCKER cqlsh"
else
  msgd "V_CQLSHRC set, including that in E_CQLSH"
  E_CQLSH="docker exec $V_DOCKER cqlsh --cqlshrc=$V_CQLSHRC"
fi
msgd "E_CQLSH: $E_CQLSH"

msgd "Construct docker sh execution command"
E_DOCKER="docker exec $V_DOCKER"
msgd "E_DOCKER: $E_DOCKER"

#WIP testing
f_load_table $V_KEYSPACE $V_TABLE
exit 0


f_cqlsh_sanity_check

# # #
msgd "Set some defaults if they were not set explicitly"
if [ -z "$V_IGNORE_KEYSPACE_EXISTS" ]; then
  msgd "V_IGNORE_KEYSPACE_EXISTS was not set explicitly, setting to no"
  V_IGNORE_KEYSPACE_EXISTS=no
fi
if [ -z "$V_IGNORE_TABLE_EXISTS" ]; then
  msgd "V_IGNORE_TABLE_EXISTS was not set explicitly, setting to no"
  V_IGNORE_TABLE_EXISTS=no
fi

msgd "V_IGNORE_KEYSPACE_EXISTS: $V_IGNORE_KEYSPACE_EXISTS"
msgd "V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS"

# # # Actual execution
# # # restore a table
msgd "Check what should I do"
if [ "$V_KEYSPACE" ] && [ "$V_TABLE" ]; then
  msgd "Both keyspace and table is provided, so I am about to restore a table"
  f_check_if_keyspace_exists $V_KEYSPACE

  msgd "V_CHECK_IF_KEYSPACE_EXISTS: $V_CHECK_IF_KEYSPACE_EXISTS"
  if [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "no" ]; then
    msge "You want to restore a table in a keyspace but the keyspace does not exists. Exiting."
  elif [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "yes" ]; then
    msgd "Keyspace exists. Continuing."
    msgd "Checking if table already exists"
    f_check_if_table_exists $V_KEYSPACE $V_TABLE

    msgd "V_CHECK_IF_TABLE_EXISTS: $V_CHECK_IF_TABLE_EXISTS"
    if [ "$V_CHECK_IF_TABLE_EXISTS" = "no" ]; then
      msgd "Keyspace exists, table does not. Creating table and loading data"
      f_create_table_structure $V_KEYSPACE $V_TABLE
      f_load_table $V_KEYSPACE $V_TABLE
#WIP
msgd "ala ma kota"
exit 0
    elif [ "$V_CHECK_IF_TABLE_EXISTS" = "yes" ]; then
      msgd "Keyspace exists, table exists. Deciding what to do based on V_IGNORE_TABLE_EXISTS value"
      if [ "$V_IGNORE_TABLE_EXISTS" = "no" ]; then
        msge "Table $V_TABLE already exists in the keyspace $V_KEYSPACE."
        msge "There was no parameter set to ignore it (use '--ignore_table_exists yes' to force loading data anyway) "
        msge "Exiting."
        exit 1
      elif [ "$V_IGNORE_TABLE_EXISTS" = "yes" ]; then
        msgd "Table $V_TABLE already exists in the keyspace $V_KEYSPACE."
        msgd "There WAS parameter set to ignore it, loading data anyway) "
        f_load_table $V_KEYSPACE $V_TABLE
      else
        msge "Unknown value of V_IGNORE_TABLE_EXISTS: $V_IGNORE_TABLE_EXISTS. Exiting"
        exit 1 
      fi
    else
      msge "Unknown value of V_CHECK_IF_TABLE_EXISTS: $V_CHECK_IF_TABLE_EXISTS. Exiting"
      exit 1
    fi
  else
    msge "Unknown value of V_CHECK_IF_KEYSPACE_EXISTS: $V_CHECK_IF_KEYSPACE_EXISTS. Exiting"
  fi #  if [ "$V_CHECK_IF_KEYSPACE_EXISTS" = "no" ]; then

elif [ "$V_KEYSPACE" ] && [ -z "$V_TABLE" ]; then
  msgd "Only keyspace provided, so I am about to restore whole one keyspace or all keyspaces" 
else
  msge "Provide keyspace"
fi



msgd "Check if sstableloader exists in docker"


